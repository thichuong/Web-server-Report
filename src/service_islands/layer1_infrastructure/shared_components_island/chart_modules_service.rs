//! Chart Modules Service
//!
//! Layer 1 service responsible for managing chart modules JavaScript assets.
//! Pre-loads and caches all chart modules content during server startup for optimal performance.

use anyhow::Result;
use std::path::Path;
use std::sync::Arc;
use tokio::fs::{read_dir, read_to_string};
use tracing::{debug, info, warn};

/// Chart Modules Service
///
/// Manages JavaScript chart modules for the application.
/// Pre-loads all chart modules during startup to eliminate I/O during runtime.
#[derive(Debug, Clone)]
pub struct ChartModulesService {
    #[allow(dead_code)]
    base_path: String,
    chart_modules_content: Arc<String>,
}

impl ChartModulesService {
    /// Create a new `ChartModulesService` and pre-load all chart modules
    ///
    /// # Errors
    ///
    /// Returns error if chart module files cannot be read or directory access fails
    pub async fn new() -> Result<Self> {
        debug!("ðŸ“¦ Layer 1: Khá»Ÿi táº¡o ChartModulesService...");

        // Default priority order for chart modules
        let priority_order = vec![
            "gauge.js".to_string(),
            "bar.js".to_string(),
            "line.js".to_string(),
            "pie.js".to_string(),
            "doughnut.js".to_string(),
        ];

        let chart_content = Self::prepare_chart_modules(&priority_order).await?;
        info!(
            "âœ… Layer 1: Chart modules Ä‘Ã£ sáºµn sÃ ng. ({} bytes)",
            chart_content.len()
        );

        Ok(Self {
            base_path: "shared_assets/js/chart_modules".to_string(),
            chart_modules_content: Arc::new(chart_content),
        })
    }

    /// Pre-load and concatenate all chart modules JavaScript files
    async fn prepare_chart_modules(priority_order: &[String]) -> Result<String> {
        let source_dir = Path::new("shared_assets").join("js").join("chart_modules");

        if !source_dir.exists() {
            warn!("âš ï¸ Chart modules directory not found: {:?}", source_dir);
            return Ok(String::new());
        }

        let mut final_content = String::new();
        final_content.push_str("// Chart Modules - Pre-loaded during server startup\n");
        final_content.push_str("// Generated by ChartModulesService\n\n");

        // Read all files in the directory
        let mut dir_entries = read_dir(&source_dir).await?;
        let mut all_files = Vec::new();

        while let Some(entry) = dir_entries.next_entry().await? {
            let path = entry.path();
            if path.is_file() && path.extension().is_some_and(|ext| ext == "js") {
                if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                    all_files.push(file_name.to_string());
                }
            }
        }

        // Sort files according to priority order
        let mut sorted_files = Vec::new();

        // First, add files in priority order
        for priority_file in priority_order {
            if all_files.contains(priority_file) {
                sorted_files.push(priority_file.clone());
            }
        }

        // Then add remaining files
        for file in &all_files {
            if !sorted_files.contains(file) {
                sorted_files.push(file.clone());
            }
        }

        debug!(
            "ðŸ“¦ Layer 1: Loading chart modules in order: {:?}",
            sorted_files
        );

        // Read and concatenate files
        for file_name in &sorted_files {
            let file_path = source_dir.join(file_name);
            match read_to_string(&file_path).await {
                Ok(content) => {
                    use std::fmt::Write;
                    writeln!(final_content, "// === {file_name} ===").ok();
                    final_content.push_str(&content);
                    final_content.push_str("\n\n");
                    debug!("  âœ… Loaded: {} ({} bytes)", file_name, content.len());
                }
                Err(e) => {
                    warn!("  âš ï¸ Failed to load {}: {}", file_name, e);
                }
            }
        }

        Ok(final_content)
    }

    /// Get the pre-loaded chart modules content
    #[must_use] 
    pub fn get_content(&self) -> Arc<String> {
        self.chart_modules_content.clone()
    }

    /// Health check
    #[must_use] 
    pub fn health_check(&self) -> bool {
        !self.chart_modules_content.is_empty()
    }
}
