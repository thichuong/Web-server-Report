//! Chart Modules Service
//! 
//! Layer 1 service responsible for managing chart modules JavaScript assets.
//! Pre-loads and caches all chart modules content during server startup for optimal performance.

use std::sync::Arc;
use std::path::Path;
use tokio::fs::{read_dir, read_to_string};
use anyhow::Result;

/// Chart Modules Service
/// 
/// Manages JavaScript chart modules for the application.
/// Pre-loads all chart modules during startup to eliminate I/O during runtime.
#[derive(Debug, Clone)]
pub struct ChartModulesService {
    #[allow(dead_code)]
    base_path: String,
    chart_modules_content: Arc<String>,
}

impl ChartModulesService {
    /// Create a new ChartModulesService and pre-load all chart modules
    pub async fn new() -> Result<Self> {
        println!("📦 Layer 1: Khởi tạo ChartModulesService...");
        
        // Default priority order for chart modules
        let priority_order = vec![
            "gauge.js".to_string(),
            "bar.js".to_string(),
            "line.js".to_string(),
            "pie.js".to_string(),
            "doughnut.js".to_string(),
        ];
        
        let chart_content = Self::prepare_chart_modules(&priority_order).await?;
        println!("✅ Layer 1: Chart modules đã sẵn sàng. ({} bytes)", chart_content.len());
        
        Ok(Self {
            base_path: "shared_assets/js/chart_modules".to_string(),
            chart_modules_content: Arc::new(chart_content),
        })
    }
    
    /// Pre-load and concatenate all chart modules JavaScript files
    async fn prepare_chart_modules(priority_order: &[String]) -> Result<String> {
        let source_dir = Path::new("shared_assets").join("js").join("chart_modules");
        
        if !source_dir.exists() {
            println!("⚠️ Chart modules directory not found: {:?}", source_dir);
            return Ok(String::new());
        }
        
        let mut final_content = String::new();
        final_content.push_str("// Chart Modules - Pre-loaded during server startup\n");
        final_content.push_str("// Generated by ChartModulesService\n\n");
        
        // Read all files in the directory
        let mut dir_entries = read_dir(&source_dir).await?;
        let mut all_files = Vec::new();
        
        while let Some(entry) = dir_entries.next_entry().await? {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "js") {
                if let Some(file_name) = path.file_name().and_then(|n| n.to_str()) {
                    all_files.push(file_name.to_string());
                }
            }
        }
        
        // Sort files according to priority order
        let mut sorted_files = Vec::new();
        
        // First, add files in priority order
        for priority_file in priority_order {
            if all_files.contains(priority_file) {
                sorted_files.push(priority_file.clone());
            }
        }
        
        // Then add remaining files
        for file in &all_files {
            if !sorted_files.contains(file) {
                sorted_files.push(file.clone());
            }
        }
        
        println!("📦 Layer 1: Loading chart modules in order: {:?}", sorted_files);
        
        // Read and concatenate files
        for file_name in &sorted_files {
            let file_path = source_dir.join(file_name);
            match read_to_string(&file_path).await {
                Ok(content) => {
                    final_content.push_str(&format!("// === {} ===\n", file_name));
                    final_content.push_str(&content);
                    final_content.push_str("\n\n");
                    println!("  ✅ Loaded: {} ({} bytes)", file_name, content.len());
                }
                Err(e) => {
                    println!("  ⚠️ Failed to load {}: {}", file_name, e);
                }
            }
        }
        
        Ok(final_content)
    }
    
    /// Get the pre-loaded chart modules content
    pub fn get_content(&self) -> Arc<String> {
        self.chart_modules_content.clone()
    }
    
    /// Health check
    pub async fn health_check(&self) -> bool {
        !self.chart_modules_content.is_empty()
    }
}
