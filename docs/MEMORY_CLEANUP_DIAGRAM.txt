```
MEMORY CLEANUP FLOW - ChartModulesIsland
═════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────┐
│ get_chart_modules_content() CALLED                              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 1: Read directory & collect .js files                      │
│   ├─ entries: tokio::fs::ReadDir                               │
│   ├─ all_files: Vec<String>                                    │
│   └─ Memory: Stack allocated                                   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 2: Order files by priority                                 │
│   ├─ ordered: Vec<String>                                      │
│   └─ all_files moved/consumed                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 3: Create async futures (into_iter - ownership transfer)   │
│   ├─ file_futures: Vec<Future>                                 │
│   ├─ Each filename MOVED into closure                          │
│   └─ ordered Vec consumed ✅ (no clone!)                        │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 4: Read files concurrently                                 │
│   ├─ futures::join_all() awaits all                            │
│   ├─ Each future reads file & wraps content                    │
│   │   └─ String::with_capacity() - pre-allocated ✅             │
│   └─ Results: Vec<String>                                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 5: Concatenate in blocking thread                          │
│   ├─ parts Vec moved into spawn_blocking                       │
│   ├─ join("\n\n") creates final String                         │
│   └─ parts Vec dropped in blocking task ✅                      │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 6: Return final_content                                    │
│   └─ All intermediate allocations cleaned up ✅                 │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                      ┌───────────────┐
                      │ Memory freed! │
                      └───────────────┘

═════════════════════════════════════════════════════════════════════

MEMORY CLEANUP FLOW - CacheManager::get()
═════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────┐
│ get(key) CALLED                                                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 1: Try L1 cache (fast path)                               │
│   ├─ No allocation                                              │
│   └─ If HIT → return immediately ✅                             │
└─────────────────────────────────────────────────────────────────┘
                              │ MISS
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 2: L1 miss - acquire lock                                  │
│   ├─ key_owned = key.to_string()                               │
│   ├─ lock_guard = DashMap entry                                │
│   └─ _cleanup_guard = CleanupGuard created 🛡️                  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 3: Acquire mutex & double-check L1                         │
│   └─ If HIT → CleanupGuard drops → DashMap cleaned ✅          │
└─────────────────────────────────────────────────────────────────┘
                              │ MISS
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 4: Check L2 cache                                          │
│   ├─ If HIT → promote to L1                                    │
│   └─ CleanupGuard drops → DashMap cleaned ✅                    │
└─────────────────────────────────────────────────────────────────┘
                              │ MISS
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│ Step 5: Both caches miss                                        │
│   ├─ Return None                                                │
│   └─ CleanupGuard drops → DashMap cleaned ✅                    │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────────┐
                    │ RAII ensures        │
                    │ cleanup in ALL      │
                    │ code paths! 🛡️      │
                    └─────────────────────┘

KEY SAFETY FEATURES:
═══════════════════════════════════════════════════════════════════
✅ CleanupGuard implements Drop trait
✅ Runs even on panic or early return
✅ No manual cleanup needed
✅ Zero overhead (compile-time optimization)

═══════════════════════════════════════════════════════════════════

DROP TRAIT EXECUTION ORDER
═══════════════════════════════════════════════════════════════════

When function returns or panics:

1. _cleanup_guard.drop()  ← Removes DashMap entry
   │
2. _guard.drop()          ← Releases Mutex
   │
3. lock_guard.drop()      ← Drops Arc<Mutex<()>>
   │
4. key_owned.drop()       ← Frees String allocation
   │
5. Stack frame cleared    ← All local variables freed

═══════════════════════════════════════════════════════════════════

MEMORY LEAK PROTECTION
═══════════════════════════════════════════════════════════════════

❌ BEFORE (Potential leak):
   - DashMap entry only removed on success
   - Early return → entry leaked
   - Panic → entry leaked

✅ AFTER (Guaranteed cleanup):
   - RAII guard always drops
   - Early return → guard.drop() called
   - Panic → guard.drop() called during unwind
   - Exception-safe!

═══════════════════════════════════════════════════════════════════
```
